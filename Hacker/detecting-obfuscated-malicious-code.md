# 使用熵识别混淆恶意代码

在典型的软件程序中，可以通过简单地检查程序包含的字符串来确定有关程序的大量信息。例如，您可以查看程序使用的文件、网络地址或主机名、环境变量和运行时库。当然，使用静态分析程序很容易辨别这些，但即使是像 GNU 字符串这样的简单实用程序也非常适合检查它们。

为了避免检测，某些作者可能希望通过使这些字符串不那么透明来故意掩盖程序的性质。

虽然有一些合法的情况可以这样做，但恶意软件经常试图通过混淆包源代码中的数据、字符串和函数来隐藏其活动。这通过屏蔽恶意代码用于操作的关键机制来抑制对应用程序的分析。

在现代软件工程世界中，在用户机器上执行的大量代码（无论是在浏览器中还是作为独立进程）都是动态的[解释代码](https://medium.com/young-coder/the-difference-between-compiled-and-interpreted-languages-d54f66aa71f0)。一般来说，这意味着运行的代码以人类可读的文本开始。从某种角度来看，整个程序是一个字符串，这使得确定程序在做什么变得微不足道。

事实证明，在浏览器中运行的 JavaScript 是混淆的沃土。一个常见的恶意用例很简单：完全混淆恶意代码，然后在运行时对其进行反混淆，然后通过简单地调用“eval()”来执行它。

在这种情况下使用的混淆通常很容易解开，利用轻量级的通用编码，如 base64、url 编码或简单的 XOR 转换，而不是使用实际的加密。这通常（尽管并非总是）会导致具有更高熵的字符串。简而言之，[熵](https://en.wikipedia.org/wiki/Entropy_(information_theory))是对给定字符串中包含的信息密度或平均信息水平的度量。虽然高熵或编码数据块的存在通常并不表示恶意软件，但几乎所有恶意软件都会包含一些加密/编码数据块。 

Ref:

[Using Entropy to Identify Obfuscated Malicious Code](https://blog.phylum.io/detecting-obfuscated-malicious-code)