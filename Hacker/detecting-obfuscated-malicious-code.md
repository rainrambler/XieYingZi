# 使用熵识别混淆恶意代码

在典型的软件程序中，可以通过简单地检查程序包含的字符串来确定有关程序的大量信息。例如，您可以查看程序使用的文件、网络地址或主机名、环境变量和运行时库。当然，使用静态分析程序很容易辨别这些，但即使是像 GNU 字符串这样的简单实用程序也非常适合检查它们。

为了避免检测，某些作者可能希望通过使这些字符串不那么透明来故意掩盖程序的性质。

虽然有一些合法的情况可以这样做，但恶意软件经常试图通过混淆包源代码中的数据、字符串和函数来隐藏其活动。这通过屏蔽恶意代码用于操作的关键机制来抑制对应用程序的分析。

在现代软件工程世界中，在用户机器上执行的大量代码（无论是在浏览器中还是作为独立进程）都是动态的[解释代码](https://medium.com/young-coder/the-difference-between-compiled-and-interpreted-languages-d54f66aa71f0)。一般来说，这意味着运行的代码以人类可读的文本开始。从某种角度来看，整个程序是一个字符串，这使得确定程序在做什么变得微不足道。

事实证明，在浏览器中运行的 JavaScript 是混淆的沃土。一个常见的恶意用例很简单：完全混淆恶意代码，然后在运行时对其进行反混淆，然后通过简单地调用“eval()”来执行它。

在这种情况下使用的混淆通常很容易解开，利用轻量级的通用编码，如 base64、url 编码或简单的 XOR 转换，而不是使用实际的加密。这通常（尽管并非总是）会导致具有更高熵的字符串。简而言之，[熵](https://en.wikipedia.org/wiki/Entropy_(information_theory))是对给定字符串中包含的信息密度或平均信息水平的度量。虽然高熵或编码数据块的存在通常并不表示恶意软件，但几乎所有恶意软件都会包含一些加密/编码数据块。 

## 用于混淆的一些常见编码

为了说明上述情况，我们测量了使用各种常见混淆技术混淆的字符串的熵。 原始未混淆字符串是一段“[Lorem ipsum](https://lipsum.com/)”文本，香农熵约为 4.179。 

对于唯一使用的实际加密方案（虽然已弃用且相对不安全但方便），RC4，熵比原始源字符串高得多，因此很容易挑选出来。这是可以预料的。此外，base64 编码导致比源字符串显着更高的熵。

不出所料，使用单个字符值对字符串进行 XOR 编码会导致混淆后的字符串与原始字符串具有相同的熵。这是源字符到编码字符的一对一替换映射。

在上述常见方案中，只有 URL 编码会导致编码字符串的熵低于原始字符串。因此，考虑具有平均熵显着低于预期值的字符串的代码样本可能会被证明是有用的。

## 一个真实世界的例子

混淆字符串出现在大多数 JavaScript 漏洞利用工具包中。目标是隐藏行为。下面的屏幕截图直接取自最近用于通过冒充 Google 标签管理器脚本来浏览信用卡信息的恶意代码示例。

Ref:

[Using Entropy to Identify Obfuscated Malicious Code](https://blog.phylum.io/detecting-obfuscated-malicious-code)